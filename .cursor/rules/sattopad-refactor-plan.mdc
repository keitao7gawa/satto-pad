---
alwaysApply: false
---
# SattoPad リファクタリング計画（Cursor Rules）

## 目的 / 方針
- 現在の機能・挙動を一切崩さず、読みやすさ・保守性・安全性を高める。
- UI/UXは据え置き。内部構造の整理・重複の削減・責務分離・命名/定数化を中心に行う。
 - 「軽さ（低レイテンシ/低CPU/低メモリ）」を最優先の品質として守る。

## 非機能要件（絶対条件）
- 既存の操作フロー・ホットキー・オーバーレイ挙動・自動保存/読み込みのユーザー体験を変えない。
- ビルド警告を増やさない。コンパイルエラーを出さない。
- 変更は段階的・小さく・差分が読みやすい単位で行う。
 - パフォーマンス予算（目安）を守る: オーバーレイ表示/非表示 < 50ms、常時CPU < 1%、メモリ < 100MB。

## 対象コンポーネントと改善方針

### 1) `ContentView`
- 問題: 肥大化（ヘッダーUI/メニュー/編集部/通知/バインディングが混在）
- 改善:
  - ヘッダーUIのサブビュー化（例: `OverlayHeaderView`）。
  - 右端の「… + ×」小ペア（タイトな間隔/小ヒット領域）を小コンポーネントへ切出し（例: `TrailingMenuButtons`）。
  - フォントサイズ調整UI（A-/A+ と pt 表示）を小コンポーネント化（例: `FontStepperView`）。
  - Magic number（スライダー幅110、アイコン18×18、フォント範囲8–36、spacing）を `HeaderLayoutConstants` に集約。
  - `RepeatButton` を別ファイルへ移動（共通UI部品として再利用）。
  - ジェスチャ/タイマーは必要最小限に。バックグラウンド処理は行わない（UIスレッドで完結）。

### 2) `OverlayPreviewView`
- 問題: Markdownレンダリング・表示ロジックが1ファイルに集中。拡張性が限定的。
- 改善:
  - 簡易Markdownパーサを `MarkdownRenderer`（struct）に抽出。ブロック判定/インデント/タスクリストを関数分割。
  - ベースフォント/見出し倍率/行間などのタイポ設定を `OverlayTypography` としてまとめる。
  - `@AppStorage` 直参照を最小化し、必要であれば引数/環境から受け取れる設計へ（テスト容易性向上）。
  - レンダリングは同期/逐次で軽量に維持。不要な再計算・再レイアウトを避ける（`@State`/`@AppStorage` の更新粒度を最小化）。

### 3) `OverlayManager`
- 問題: 状態切替とNSWindowDelegate処理の凝集度が低い。
- 改善:
  - 調整モード切替（マウスイベント/移動/リサイズ/スタイルマスク変更）を1メソッドに集約。
  - リサイズの保存は `windowDidEndLiveResize` のみで行い、`windowDidResize` の責務を縮小。
  - ウィンドウ生成・初期化・表示・位置復元を関数分割（読みやすさ向上）。
  - リサイズ/移動は暗黙アニメーション無効で即時反映（既存実装踏襲）。タイマーやループは導入しない。

### 4) `OverlaySettingsStore`
- 問題: UserDefaultsキー/型が散在。
- 改善:
  - キーをネームスペース化（enum/静的letを`private enum Keys`へ）。
  - 可能なら `@propertyWrapper` で UserDefaults アクセスを簡潔化。

### 5) `MarkdownStore`
- 問題: デバウンスとI/O/監視のコードが混在しがち。
- 改善:
  - デバウンスは Combine（`@Published text` + `debounce`) 構成を検討（挙動を変えない範囲）。
  - 監視（DispatchSource）開始/停止/再開を小関数化。URL変更時の再初期化フローを明確に。
  - ブックマーク作成/解決をヘルパーに抽出。フォールバックとエラー処理を一元化。
  - 監視イベントはスロットリング（連続writeのスパイクを吸収）。自分の書き込みは短時間無視（既存lastWriteAt維持）。

### 6) スタイル/ユーティリティ
- `CompactIconMenuStyle` と `HideMenuIndicatorIfAvailable` を `UI/Styles` に集約。
- `RepeatButton` を `UI/Components` へ移動し、初期遅延/間隔のデフォルトを定数化。

## 命名/定数/コメントの指針
- 命名は「目的語つきの動詞/名詞」を優先（例: `setOverlayAdjustable`）。
- コメントは「なぜ」を書く（数値根拠・OSバージョン差・UI決定の理由）。
- マジックナンバーは定数化。既存UIの見た目を崩さない値に固定。

## 手順（安全な順序）
1. ヘッダーのレイアウト定数を導入（現行値をそのまま定数化）。
2. `RepeatButton` / `CompactIconMenuStyle` / `HideMenuIndicatorIfAvailable` を別ファイルへ移す（import先を更新）。
3. 右端「… + ×」ペアを小コンポーネント化し、両バリアントへ適用（機能差なし）。
4. フォントステッパーを小コンポーネント化（A-/A+ 長押し含む）。
5. `OverlayPreviewView` のレンダリング補助（`MarkdownRenderer` / `OverlayTypography`）抽出。
6. `OverlayManager` の状態切替とウィンドウイベントを関数分割。
7. `OverlaySettingsStore` のキー整理（リネームによる互換性に注意：既存キーは維持）。
8. `MarkdownStore` の関数分割（挙動維持を最優先。デバウンスのCombine移行は別PRでも可）。
 9. 各ステップで軽量計測（簡易ログ/計測）でCPUスパイクやレイアウト遅延がないことを確認。

## 受け入れ基準（回帰テスト）
- ポップオーバー表示/閉じる、ESCで閉じる、ショートカットでトグルが従来通りに動く。
- オーバーレイの表示/非表示/移動/リサイズ/透明度/フォントサイズが従来通り（リアルタイム反映、テキストは不透明）。
- 自動保存（約1秒デバウンス）、起動時復元、保存先変更、再読み込み、外部変更検知（未保存無し→自動リロード/有り→警告）が従来通り。
- UI見た目（余白/幅/当たり判定）は体感同等。三点メニュー・×・ホットキー・スライダーの並び/ヒット領域が維持される。
 - 軽さの維持: 操作中CPUスパイクが目視で発生しない、オーバーレイ表示/非表示が体感で瞬時。

## リスクと緩和
- UI崩れ: レイアウト定数を導入後は「既存値」を初期値に固定。スクリーンショット差分で確認。
- 意図しない挙動変更: 機能単位でPRを分割し、各PRで手動回帰テストを実施。
- 監視/保存周りの回帰: I/O部分のリファクタは関数抽出に留め、Combine移行は別PRにする。

## ブランチ/PR運用（推奨）
- `refactor/header-extract` → ヘッダー抽出と定数化
- `refactor/ui-styles-components` → スタイル/コンポーネント分離
- `refactor/overlay-preview-renderer` → MarkdownRenderer/タイポ抽出
- `refactor/overlay-manager-window` → ウィンドウイベント/状態切替の整理
- `refactor/settings-store-keys` → 設定キー/ラッパー化
- （オプション）`refactor/markdownstore-helpers` → 監視/ブックマーク/デバウンス整理

